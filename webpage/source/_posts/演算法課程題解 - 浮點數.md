---
title: 演算法課程題解 - 浮點數
date: 2020-10-26 22:01:59
type: Algorithm
---

# UVa 10370
## 題目
http://domen111.github.io/UVa-Easy-Viewer/?10370
有 $C$ 個班級，每個班級有 $N$ 個學生
給定 $N$ 個學生的成績，輸出每個班級有多少百分比的學生成績比班平均還高

## 想法
每個班級的成績都可以算出一個平均，算出成績後一個一個比對誰的成績比平均高，每遇到一個就紀錄下來
有了紀錄的數量以及班級學生的總數，就可以算出答案囉!

不過要特別注意兩個地方
1. 我們的平均以及答案的比例都可能會有小數，所以要用 `double` 來儲存
2. 輸出要四捨五入到小數點後第三位，記得要用 `fixed` 和 `setprecision`

## 程式碼
```cpp=
#include<iostream>
#include<iomanip> 
using namespace std;
int c,n,arr[1005];
int main(){
	cin>>c; 
	while(c--){
		cin>>n;
		double avg=0;
		for(int i=0 ; i<n ; i++){
			cin>>arr[i]; 
			avg+=arr[i];// 先將成績加總
		}
		avg/=n;// 再來算平均 
		int cnt=0;
		for(int i=0 ; i<n ; i++){
			if(arr[i]>avg)
				cnt++;// 記錄大於平均的數量 
		}
		cout<<fixed<<setprecision(3)<<((double)cnt/(double)n)*100.0<<"%\n";
	}
	return 0;
}
```

## 時間複雜度分析
有 $C$ 個班級，每個班級有 $N$ 筆成績要輸入，輸入的時間複雜度為 $O(CN)$
每次算出平均後，需要一個一個比對有多少大於平均的成績，時間複雜度為 $O(N)$
總時間複雜度為 $O(CN+N)$ ， 約為 $O(CN)$

# UVa 10491
## 題目
http://domen111.github.io/UVa-Easy-Viewer/?10491
現在有一場遊戲，遊戲的規則是這樣的:
舞台上有許多扇門，每個門後都有一輛車或是一隻牛
身為參賽者的你，目的就是要選到有車的那扇門。在遊戲的一開始，你會選擇一扇門
接下來主持人會開啟幾扇在你選擇的門以外，藏有牛的門，題目保證這扇門是存在的

問題如下:
在有 $N$ 隻牛， $M$ 輛車，主持人開啟 $S$ 扇門的情況下，你贏得車的機率是多少，輸出到小數點後第 5 位

## 想法
這題其實是數學題喔!在高中的機率當中也有類似的題目，想法是這樣的
一開始參賽者選擇的情況有兩個
1. 選擇了藏有牛的門
    一開始選擇藏有牛的門的機率為 $\frac{N}{N+M}$
    
    此時，剩下的門的數量為 $(N-1)+M-S$ ，車的數量為 $M$
    
    在這個前提下，選到車的機率為 $\frac{N}{N+M} \times \frac{M}{N+M-S-1}$
2. 選擇了藏有車的門
    一開始選擇藏有車的門的機率為 $\frac{M}{N+M}$
    
    此時，剩下的門的數量為 $N+(M-1)-S$ ，車的數量為 $M-1$
    
    在這個前提下，選到車的機率為 $\frac{N}{N+M} \times \frac{M-1}{N+M-S-1}$

最後將這兩種情況的機率相加，就會是我們的答案

記得，這裡的機率可能會含有小數，要使用 `double` 儲存
並且輸出要到小數點後第 5 位，要使用 `fixed` 和 `setprecision`

## 程式碼
```cpp=
#include<iostream>
#include<iomanip>
using namespace std;
double NCOWS, NCARS, NSHOW;
int main(){
	while(cin>>NCOWS>>NCARS>>NSHOW){
		double tot=NCOWS+NCARS;
		//choose cow
		double p1 = (NCOWS/tot) * (NCARS/(tot-1-NSHOW));
		double p2 = (NCARS/tot) * ((NCARS-1)/(tot-1-NSHOW));
		cout<<fixed<<setprecision(5)<<p1+p2<<"\n";
	}
	return 0;
}
```

## 時間複雜度分析
每一筆輸入在計算上時間複雜度為 $O(1)$

總時間複雜度為 $O(測資數量)$

# TOJ 99
## 題目
https://toj.tfcis.org/oj/pro/99/
給一個二階矩陣 $$\begin{bmatrix}a && b \\ c && d\end{bmatrix}$$
求 $$\| a\*d - b\*c \|$$ 是否非零，誤差值在小數點後 7 位

## 想法
這題是要測試是否知道使用 eps
在 C/C++ 當中，小數點只能是"大致上"準確的，所以像是小數再判斷是否為零不能直接判斷
我們通常會設定一個誤差值，像是本題就是 $10^{-7}$ ，當我們的值小於該誤差值就會被判定為 0
所以我們只需要改用 eps 來判斷就可以囉

## 程式碼
```cpp=
//By Koios1143
#include<iostream>
#include<cmath> 
using namespace std;
const double eps=1e-7;
double a,b,c,d;
int main(){
	cin>>a>>b>>c>>d;
	double result = a*d-b*c;
	if(fabs(result)>=eps){
		cout<<"1\n";
	}
	else{
		cout<<"0\n";
	}
	return 0;
}
```

## 時間複雜度分析
計算以及判斷都只有一次，時間複雜度為 $O(1)$

# UVa 12195
## 題目
http://domen111.github.io/UVa-Easy-Viewer/?12195
小李在學作曲，他想要做出每一小節長度都是 1 拍的曲子
可以用的音符有這些:
![](https://i.imgur.com/O4PyW43.png)

我們會拿到一串以 `/` 切割的字串，每個 `/` 之間代表一個小節的內容
請你判斷出其中有多少小節的長度剛好是 1 拍

## 想法1
每個小節我們都拿一個變數紀錄音符的總長度
我們可以跟著題目的想法做，遇到相對應的音符代號，就將長度記錄下來
在每個小節結束後，如果長度剛好為 1 拍，就記錄下來

輸入的部分我們可以這樣處理:
每次遇到 `/` 就看看我們紀錄音符長度的值是不是剛好為 1 拍，如果是就紀錄下來
無論有沒有剛好為 1 拍，都必須要將記錄長度的變數歸零

## 想法2
如果不想要處理麻煩的小數問題，可以這樣想
觀察可以用的音符，可以發現到所有音符長度的最小公倍數是 64
將全部的音符長度都乘上 64 後，都會變成整數，這樣就完美的忽略小數的問題了!
那麼一個小節的長度也就變成 64 囉!

## 程式碼1
```cpp=
#include<iostream>
#include<iomanip>
using namespace std;
int main(){
	string s;
	while(cin>>s){
		double cnt=0;
		int ans=0;
		if(s=="*") break;
		for(int i=0 ; i<s.size() ; i++){
			if(s[i] == '/'){
				if(cnt == 1) ans++;
				cnt=0;
			}
			else{
				if(s[i] == 'W'){
					cnt+=1.0;
				}
				else if(s[i] == 'H'){
					cnt+=0.5;
				}
				else if(s[i] == 'Q'){
					cnt+=0.25;
				}
				else if(s[i] == 'E'){
					cnt+=0.125;
				}
				else if(s[i] == 'S'){
					cnt+=0.0625;
				}
				else if(s[i] == 'T'){
					cnt+=0.03125;
				}
				else if(s[i] == 'X'){
					cnt+=0.015625;
				}
			}
		}
		cout<<ans<<'\n';
	}

	return 0;
}
```

### 程式碼2
```cpp=
#include<iostream>
#include<iomanip>
using namespace std;
int main(){
	string s;
	while(cin>>s){
		int cnt=0;
		int ans=0;
		if(s=="*") break;
		for(int i=0 ; i<s.size() ; i++){
			if(s[i] == '/'){
				if(cnt == 64) ans++;
				cnt=0;
			}
			else{
				if(s[i] == 'W'){
					cnt+=64;
				}
				else if(s[i] == 'H'){
					cnt+=32;
				}
				else if(s[i] == 'Q'){
					cnt+=16;
				}
				else if(s[i] == 'E'){
					cnt+=8;
				}
				else if(s[i] == 'S'){
					cnt+=4;
				}
				else if(s[i] == 'T'){
					cnt+=2;
				}
				else if(s[i] == 'X'){
					cnt+=1;
				}
			}
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

## 時間複雜度分析
每次輸入會針對字串的每個字原作相對應的計算
而每個計算的時間複雜度為 $O(1)$
每筆測資的時間複雜度為 $O(len(s))$

# UVa 113
## 題目
http://domen111.github.io/UVa-Easy-Viewer/?113
給定兩個整數 $n$, $p$ ，求 $p$ 的 $n$ 次方根 $k$ ，且保證 $k$ 為整數

## 想法
$p$ 的 $n$ 次方根等同於 $p$ 的 $\frac{1}{n}$ 次方
直接使用內建的 `pow` 即可

有一點需要特別小心，因為 C++ 預設在輸出小數時如果太小，可能會變成以科學記號表示
要排除這種狀況，我們可以用之前學過的 `setprecision` 來解決
`setprecision(n)` 等同四捨五入取到小數點後第 $n$ 位，這裡我們要取整數，所以放 0 

## 程式碼
```cpp=
#include<iostream>
#include<iomanip>
#include<cmath>
using namespace std;
double n,p;
int main(){
	while(cin>>n>>p){
		cout<<setprecision(0)<<pow(p,1.0/n)<<'\n';
	}
	return 0;
}
```

# UVa 1185
## 題目
http://domen111.github.io/UVa-Easy-Viewer/?1185
有 $n$ 筆測資，每筆測資包含一個數字 $m$ ，求 $m!$ 是幾位數

## 想法
如果只給一個數字 $p$ ，要求 $p$ 是幾位數我們可以用高中學到的 $log_{10}p +1$ 的整數得到答案
根據 $log$ 的性質， $log_{10}{(a*b)}$ = $log_{10}{a} + log_{10}{b}$

在階乘計算上數字成長速度很快就會超過我們能儲存的大小，所以我們要利用前面提到的 $log$ 性質
要計算 $m!$ 的位數，等同於 $floor(1+\sum_{x=1}^{m}{log_{10}{x}})$
其中， $floor$ 表示取整數

## 程式碼1
```cpp=
#include<iostream>
#include<cmath>
using namespace std;
int n,m;
int main(){
	cin>>n;
	while(n--){
		cin>>m;
		double ans=0;
		for(int i=1 ; i<=m ; i++){
			ans+=log10(i);
		}
		cout<<(int)ans+1<<'\n';
	}
	return 0;
}
```
## 時間複雜度分析
每筆測資都需要花 $O(m)$ 的時間計算
總時間複雜度 $O(nm)$

## 程式碼2
我們可以將所有答案都先算起來，這樣每次詢問就可以直接回答
```cpp=
#include<iostream>
#include<cmath>
using namespace std;
int n,m;
int ans[10000005];
double tmp;
int main(){
	for(int i=1 ; i<10000005 ; i++){
		tmp+=log10(i);
		ans[i]=(int)tmp+1;
	}
	cin>>n;
	while(n--){
		cin>>m;
		cout<<ans[m]<<'\n';
	}
	return 0;
}
```

## 時間複雜度分析
預先處理答案的時間複雜度為 $O(10^7)$
每筆詢問的時間複雜度為 $O(1)$
總時間複雜度為 $O(10^7 + n)$

# UVa 10061
# UVa 10219
# UVa 10387

###### tags: `SCIST 演算法 題解`